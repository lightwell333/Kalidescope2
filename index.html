<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Kaleidoscope — Tiny Controls, Touch Tweaks (No Audio)</title>
<style>
  :root{
    --glass: rgba(10,10,14,.7);
    --line: #2a2f3a; --fg:#fff; --muted:#b8bfd4; --accent:#69f;
  }
  html,body{margin:0;height:100%;background:#000;color:var(--fg);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto}
  canvas{display:block;width:100vw;height:100vh;touch-action:none;cursor:grab}
  #dock{
    position:fixed; left:50%; top:10px; transform:translateX(-50%);
    display:flex; gap:10px; align-items:center; z-index:30;
    background:var(--glass); border:1px solid var(--line);
    padding:8px 10px; border-radius:12px; backdrop-filter:blur(10px);
    box-shadow:0 8px 30px rgba(0,0,0,.35);
  }
  #dock input[type="range"]{ width:90px }
  #dock label{ font-size:12px; display:flex; align-items:center; gap:6px; color:var(--muted) }
  #dock .sep{ width:1px; height:22px; background:var(--line); margin:0 2px }
  #dock .btn{
    font-size:12px; padding:6px 10px; border-radius:10px; border:1px solid var(--line);
    background:#11151f; color:#cfe0ff; cursor:pointer;
  }
  #dock .btn:active{ transform:translateY(1px) }
  #dock input[type="file"]{ display:none }
  #toggle{
    position:fixed; right:10px; top:10px; z-index:31;
    background:var(--glass); border:1px solid var(--line); color:var(--fg);
    padding:6px 10px; border-radius:10px; cursor:pointer; font-size:12px; backdrop-filter:blur(10px);
  }
  #hint{
    position:fixed; left:50%; bottom:14px; transform:translateX(-50%);
    color:#9fb3ff; background:rgba(20,20,35,.45); padding:6px 10px; border-radius:10px;
    font-size:12px; border:1px solid rgba(90,110,170,.35); z-index:25;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>

<button id="toggle" title="Show/Hide controls">Hide UI</button>
<div id="dock">
  <label>Speed
    <input id="speed" type="range" min="-2" max="2" step="0.001" value="0.25">
  </label>
  <label>Twist
    <input id="twist" type="range" min="-4" max="4" step="0.001" value="0.75">
  </label>
  <label>Wedges
    <input id="wedges" type="range" min="3" max="32" step="1" value="12">
  </label>
  <label>Zoom
    <input id="zoom" type="range" min="0.25" max="4" step="0.001" value="1.0">
  </label>
  <div class="sep"></div>
  <label class="btn" for="file">Load Image</label>
  <input id="file" type="file" accept="image/*">
  <button id="reset" class="btn">Reset</button>
</div>
<div id="hint">Tip: drag to rotate, drag vertically to adjust twist • pinch or mouse-wheel to zoom</div>

<script>
(() => {
  const gl = c.getContext('webgl', { antialias: true, alpha: false, preserveDrawingBuffer: true });
  if(!gl){ alert('WebGL not available'); return; }

  // DPR-aware canvas sizing
  const DPR = Math.min(2, window.devicePixelRatio || 1);
  function resize(){
    const w = Math.floor(innerWidth * DPR), h = Math.floor(innerHeight * DPR);
    if(c.width !== w || c.height !== h){
      c.width = w; c.height = h;
      c.style.width = innerWidth + 'px'; c.style.height = innerHeight + 'px';
      gl.viewport(0,0,w,h);
    }
  }
  addEventListener('resize', resize, {passive:true}); resize();

  const vsrc = `
  attribute vec2 a_pos;
  varying vec2 v_uv;
  void main(){
    v_uv = a_pos * 0.5 + 0.5;
    gl_Position = vec4(a_pos, 0.0, 1.0);
  }`;

  const fsrc = `
  precision highp float;
  varying vec2 v_uv;
  uniform vec2  u_res;
  uniform float u_time;
  uniform sampler2D u_tex;
  uniform bool  u_hasTex;

  uniform float u_k;      // wedge count
  uniform float u_speed;  // rotation speed
  uniform float u_twist;  // angle added per radius
  uniform float u_zoom;   // scale
  uniform float u_rot;    // base rotation

  // simple 2D rot
  mat2 rot2(float a){ float c=cos(a), s=sin(a); return mat2(c,-s,s,c); }

  // fallback texture (psychedelic swirl) when no image loaded
  vec3 fallbackTex(vec2 p){
    float r = length(p);
    float a = atan(p.y,p.x);
    float w = sin(8.0*a + 10.0*r - 0.7*u_time)*0.5+0.5;
    vec3 c1 = vec3(0.2,0.5,1.0);
    vec3 c2 = vec3(1.0,0.2,0.8);
    return mix(c1, c2, w);
  }

  void main(){
    // NDC centered coords
    vec2 uv = (gl_FragCoord.xy / u_res) * 2.0 - 1.0;
    uv.x *= u_res.x / u_res.y; // aspect
    vec2 p = uv;

    // polar
    float ang = atan(p.y, p.x) + u_rot + u_time * u_speed;
    float r   = length(p);

    // kaleidoscope: mirror within sector
    float sector = 6.28318530718 / max(u_k, 1.0);
    float t = ang / sector;
    float frac = fract(t);
    // mirror around center of sector; smooth seams by tiny bias
    float signed = (abs(frac - 0.5) * 2.0 - 1.0);
    float a = signed * (sector * 0.5);

    // add twist based on radius
    a += u_twist * r;

    // back to cartesian
    vec2 dir = vec2(cos(a), sin(a));
    vec2 q = dir * r;

    // zoom and slight rotation coupling for fun
    q *= 1.0 / max(u_zoom, 0.001);

    // sample texture (centered at 0.5)
    vec2 tuv = q;
    // tile softly to avoid hard edges
    vec2 tile = fract(tuv * 0.5 + 0.5);
    vec2 edge = smoothstep(0.0, 0.01, tile) * smoothstep(0.0, 0.01, 1.0 - tile);
    float vign = edge.x * edge.y;

    vec3 col;
    if(u_hasTex){
      col = texture2D(u_tex, tile).rgb;
    }else{
      col = fallbackTex(q);
    }

    // subtle glow and vignetting to reduce seam visibility
    float g = smoothstep(0.0, 1.0, 1.0 - r);
    col *= mix(0.85, 1.2, g);
    col *= mix(0.9, 1.0, vign);

    gl_FragColor = vec4(col, 1.0);
  }`;

  // shader util
  function compile(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src); gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      console.error(gl.getShaderInfoLog(s));
      throw new Error('Shader compile error');
    }
    return s;
  }
  const vs = compile(gl.VERTEX_SHADER, vsrc);
  const fs = compile(gl.FRAGMENT_SHADER, fsrc);
  const prog = gl.createProgram();
  gl.attachShader(prog, vs); gl.attachShader(prog, fs);
  gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(prog));
    throw new Error('Link error');
  }
  gl.useProgram(prog);

  // fullscreen triangle
  const vbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1,  3,-1,  -1,3
  ]), gl.STATIC_DRAW);
  const a_pos = gl.getAttribLocation(prog, 'a_pos');
  gl.enableVertexAttribArray(a_pos);
  gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

  // uniforms
  const u_res   = gl.getUniformLocation(prog, 'u_res');
  const u_time  = gl.getUniformLocation(prog, 'u_time');
  const u_tex   = gl.getUniformLocation(prog, 'u_tex');
  const u_hasTex= gl.getUniformLocation(prog, 'u_hasTex');
  const u_k     = gl.getUniformLocation(prog, 'u_k');
  const u_speed = gl.getUniformLocation(prog, 'u_speed');
  const u_twist = gl.getUniformLocation(prog, 'u_twist');
  const u_zoom  = gl.getUniformLocation(prog, 'u_zoom');
  const u_rot   = gl.getUniformLocation(prog, 'u_rot');

  // state
  let params = {
    k: 12,
    speed: 0.25,
    twist: 0.75,
    zoom: 1.0,
    rot: 0.0
  };

  // UI bindings
  const $ = sel => document.querySelector(sel);
  const elSpeed  = $('#speed');
  const elTwist  = $('#twist');
  const elWedges = $('#wedges');
  const elZoom   = $('#zoom');
  const elFile   = $('#file');
  const elReset  = $('#reset');
  const elToggle = $('#toggle');
  const elDock   = $('#dock');

  elSpeed.addEventListener('input', e => params.speed = +e.target.value);
  elTwist.addEventListener('input', e => params.twist = +e.target.value);
  elWedges.addEventListener('input', e => params.k     = +e.target.value);
  elZoom.addEventListener('input',  e => params.zoom  = +e.target.value);
  elReset.addEventListener('click', () => {
    params = { k:12, speed:0.25, twist:0.75, zoom:1.0, rot:0.0 };
    elSpeed.value = params.speed;
    elTwist.value = params.twist;
    elWedges.value= params.k;
    elZoom.value  = params.zoom;
  });
  let dockVisible = true;
  elToggle.addEventListener('click', () => {
    dockVisible = !dockVisible;
    elDock.style.display = dockVisible ? 'flex' : 'none';
    elToggle.textContent = dockVisible ? 'Hide UI' : 'Show UI';
  });

  // Texture handling
  let tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  // temporary 1x1 pixel
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,new Uint8Array([30,30,40,255]));
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);

  let hasTex = false;
  function loadImage(src){
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img);
      gl.generateMipmap(gl.TEXTURE_2D);
      hasTex = true;
    };
    img.src = src;
  }
  elFile.addEventListener('change', e=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    const reader = new FileReader();
    reader.onload = ev => loadImage(ev.target.result);
    reader.readAsDataURL(f);
  });

  // drag & drop support
  document.addEventListener('dragover', e=>{ e.preventDefault(); }, false);
  document.addEventListener('drop', e=>{
    e.preventDefault();
    if(e.dataTransfer.files && e.dataTransfer.files[0]){
      const f = e.dataTransfer.files[0];
      if(!/^image\//.test(f.type)) return;
      const reader = new FileReader();
      reader.onload = ev => loadImage(ev.target.result);
      reader.readAsDataURL(f);
    }
  }, false);

  // Pointer controls — horizontal drag = rotate, vertical drag = twist; pinch/wheel = zoom
  let dragging = false;
  let lastX = 0, lastY = 0;
  function onDown(e){
    dragging = true;
    c.style.cursor = 'grabbing';
    const p = e.touches ? e.touches[0] : e;
    lastX = p.clientX; lastY = p.clientY;
  }
  function onMove(e){
    if(!dragging) return;
    const p = e.touches ? e.touches[0] : e;
    const dx = (p.clientX - lastX) / innerWidth;
    const dy = (p.clientY - lastY) / innerHeight;
    lastX = p.clientX; lastY = p.clientY;
    params.rot   += dx * Math.PI * 2.0;     // rotate
    params.twist += dy * 4.0;               // twist adjust
    elTwist.value = params.twist;
  }
  function onUp(){ dragging = false; c.style.cursor='grab'; }
  c.addEventListener('mousedown', onDown);
  addEventListener('mousemove', onMove);
  addEventListener('mouseup', onUp);
  c.addEventListener('touchstart', e=>{ onDown(e); e.preventDefault(); }, {passive:false});
  c.addEventListener('touchmove',  e=>{ onMove(e); e.preventDefault(); }, {passive:false});
  c.addEventListener('touchend',   e=>{ onUp(e); e.preventDefault(); }, {passive:false});

  // Pinch zoom
  let lastDist = 0;
  c.addEventListener('touchmove', e=>{
    if(e.touches && e.touches.length===2){
      const [a,b] = [e.touches[0], e.touches[1]];
      const d = Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);
      if(lastDist){
        const dd = (d - lastDist) / 200.0;
        params.zoom = Math.min(4, Math.max(0.25, params.zoom * (1 - dd)));
        elZoom.value = params.zoom;
      }
      lastDist = d;
    } else {
      lastDist = 0;
    }
  }, {passive:false});

  // Wheel zoom
  c.addEventListener('wheel', e=>{
    const delta = Math.sign(e.deltaY) * 0.05;
    params.zoom = Math.min(4, Math.max(0.25, params.zoom * (1 + delta)));
    elZoom.value = params.zoom;
    e.preventDefault();
  }, {passive:false});

  // Animate
  const t0 = performance.now();
  function frame(){
    resize();
    const t = (performance.now() - t0) / 1000;

    gl.useProgram(prog);
    gl.uniform2f(u_res, c.width, c.height);
    gl.uniform1f(u_time, t);
    gl.uniform1i(u_tex, 0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.uniform1i(u_hasTex, hasTex ? 1 : 0);

    gl.uniform1f(u_k, params.k);
    gl.uniform1f(u_speed, params.speed);
    gl.uniform1f(u_twist, params.twist);
    gl.uniform1f(u_zoom, params.zoom);
    gl.uniform1f(u_rot, params.rot);

    gl.drawArrays(gl.TRIANGLES, 0, 3);
    requestAnimationFrame(frame);
  }
  frame();

  // Load a gentle default gradient image (optional) — or just rely on fallback shader colors.
  // Uncomment to auto-load a placeholder:
  // loadImage('https://picsum.photos/1024/1024');

})();
</script>
</body>
</html>
