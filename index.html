<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Kaleidoscope Turntable ‚Ä¢ Touch + Audio + Record</title>
<style>
  :root{
    --glass: rgba(12,12,16,.78);
    --fg:#f7f9ff; --muted:#b8bfd6; --line:#2a3040; --accent:#77e6ff;
  }
  html,body{margin:0;height:100%;background:#000;color:var(--fg);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  canvas{display:block;width:100vw;height:100vh;touch-action:none;cursor:grab}

  /* Dock */
  #dock{
    position:fixed;left:50%;top:10px;transform:translateX(-50%);
    display:flex;gap:10px;align-items:center;
    background:var(--glass);border:1px solid var(--line);border-radius:14px;
    padding:8px 10px;backdrop-filter: blur(10px);z-index:20; user-select:none;
  }
  #dock.collapsed { padding:6px 8px; }
  #dock button,#dock label,#dock input[type="range"]{
    font:600 12px/1 system-ui; color:var(--fg);
  }
  #dock .group{display:flex;gap:10px;align-items:center}
  #dock .v{display:flex;flex-direction:column;gap:6px}
  #dock .lab{font:600 10px;color:var(--muted);margin-top:-2px}
  #dock input[type="range"]{width:120px}
  #dock input[type="file"]{display:none}
  .pill{
    background:#111a; border:1px solid var(--line); padding:6px 10px; border-radius:12px;
  }
  .btn{
    background:#0a0f17; border:1px solid var(--line);
    padding:8px 10px;border-radius:10px;cursor:pointer
  }
  .btn:hover{outline:1px solid #395;filter:brightness(1.1)}
  .icon{font-size:16px;display:inline-block;transform:translateY(1px)}

  /* Toggle */
  #toggle{
    position:fixed;right:10px;top:10px;z-index:21;
    background:var(--glass);border:1px solid var(--line);border-radius:12px;
    padding:8px 10px;cursor:pointer;user-select:none
  }

  /* Audio Wheel */
  #wheel{
    position:fixed;right:14px;bottom:14px;width:140px;height:140px;border-radius:50%;
    background:var(--glass);border:1px solid var(--line);backdrop-filter: blur(10px);
    display:grid;place-items:center;z-index:15;user-select:none;touch-action:none;
  }
  #wheel:after{
    content:"";position:absolute;inset:10px;border-radius:50%;
    border:1px dashed #38445e;
  }
  #needle{
    position:absolute;width:2px;height:58px;background:#9df;top:12px;left:50%;
    transform-origin:bottom center;transform:translateX(-50%) rotate(0deg);
    box-shadow:0 0 8px #9df;
  }
  #wheel .readout{
    position:absolute;bottom:10px;left:50%;transform:translateX(-50%);
    font:700 12px/1 system-ui;color:#cfe6ff;background:#0007;padding:4px 8px;border-radius:8px;border:1px solid var(--line)
  }

  /* Tiny help hint */
  #hint{
    position:fixed;left:10px;bottom:10px;z-index:14;
    color:#cfe6ff;background:#0007;border:1px solid var(--line);
    padding:6px 8px;border-radius:10px;font:600 11px/1.2 system-ui
  }

  /* Donate */
  #donate{
    position:fixed;left:10px;top:10px;z-index:21;display:flex;gap:8px;
    background:var(--glass);border:1px solid var(--line);border-radius:12px;padding:6px 8px
  }
  #donate a{
    color:#aef;text-decoration:none;font:700 12px/1 system-ui;background:#0a0f17;
    border:1px solid var(--line);padding:6px 8px;border-radius:8px
  }

  /* Hidden helper video for textures */
  video, audio{ display:none }
</style>
</head>
<body>
  <canvas id="gl"></canvas>

  <!-- Donate buttons -->
  <div id="donate">
    <a href="https://cash.app/$lightwell333" target="_blank">Cash App</a>
    <a href="https://paypal.me/lightwell333" target="_blank">PayPal</a>
  </div>

  <!-- Toggle dock -->
  <div id="toggle" title="Show / Hide controls">‚ò∞</div>

  <!-- Control Dock -->
  <div id="dock" class="">
    <div class="group">
      <label class="btn" for="mediaIn"><span class="icon">üñºÔ∏è</span> Image/Video</label>
      <input id="mediaIn" type="file" accept="image/*,video/*"/>
      <label class="btn" for="audioIn"><span class="icon">üéµ</span> Audio</label>
      <input id="audioIn" type="file" accept="audio/*"/>
      <button id="shot" class="btn">üì∏ Screenshot</button>
      <button id="rec" class="btn">‚è∫ Start</button>
      <button id="stop" class="btn" disabled>‚èπ Stop</button>
    </div>

    <div class="group v">
      <div class="lab">Wedges</div>
      <input id="wedges" type="range" min="3" max="48" step="1" value="12">
    </div>
    <div class="group v">
      <div class="lab">Zoom</div>
      <input id="zoom" type="range" min="0.2" max="3" step="0.01" value="1.1">
    </div>
    <div class="group v">
      <div class="lab">Spin</div>
      <input id="spin" type="range" min="-2" max="2" step="0.001" value="0.15">
    </div>
    <div class="group v">
      <div class="lab">Twist</div>
      <input id="twist" type="range" min="-6" max="6" step="0.01" value="0.6">
    </div>
    <div class="group v">
      <div class="lab">Tunnel</div>
      <input id="tunnel" type="range" min="0" max="1" step="0.001" value="0.18">
    </div>
    <div class="group v">
      <div class="lab">Soft Edge</div>
      <input id="soft" type="range" min="0" max="0.2" step="0.001" value="0.04">
    </div>

    <div class="group">
      <button id="mode" class="btn pill" title="Switch between Image and Procedural">Mode: Image</button>
      <button id="random" class="btn">üé≤ Chaos</button>
      <button id="reset" class="btn">‚Ü∫ Reset</button>
    </div>
  </div>

  <!-- Audio turntable wheel -->
  <div id="wheel" title="Drag around to tweak audio">
    <div id="needle"></div>
    <div class="readout" id="audioInfo">1.00√ó ‚Ä¢ 2.0kHz</div>
  </div>

  <div id="hint">Touch tips: 1-finger = rotate, 2-finger pinch = zoom, 2-finger rotate = twist. H key toggles controls.</div>

  <video id="vid" playsinline loop muted></video>
  <audio id="aud" controls></audio>

<script>
(() => {
  const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
  const canvas = document.getElementById('gl');
  const gl = canvas.getContext('webgl', {preserveDrawingBuffer:true, antialias:true});
  if(!gl){ alert('WebGL not available'); return; }

  // Resize
  function fit(){
    const w = Math.floor(innerWidth * dpr), h = Math.floor(innerHeight * dpr);
    if (canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
      gl.viewport(0,0,w,h);
    }
  }
  addEventListener('resize', fit, {passive:true}); fit();

  // Shaders
  const vsrc = `
    attribute vec2 a_pos;
    varying vec2 v_uv;
    void main(){
      v_uv = a_pos*0.5+0.5;
      gl_Position = vec4(a_pos,0.0,1.0);
    }`;
  const fsrc = `
    precision highp float;
    varying vec2 v_uv;
    uniform vec2  u_res;
    uniform float u_time;
    uniform sampler2D u_tex;
    uniform bool  u_hasTex;
    uniform float u_rot;    // base rotation
    uniform float u_zoom;   // zoom (1=normal)
    uniform float u_twist;  // swirl factor
    uniform float u_tunnel; // depth warp
    uniform float u_soft;   // feather near wedge edge
    uniform float u_k;      // wedge count (>=3)
    uniform int   u_mode;   // 0=image, 1=procedural

    // rotate 2D matrix
    mat2 rot2(float a){ float c=cos(a), s=sin(a); return mat2(c,-s,s,c); }

    vec3 palette(float t){
      // cute neon palette
      return 0.5 + 0.5*cos(6.28318*vec3(0.0,0.33,0.67)*1.0 + t*vec3(1.3,1.7,2.1));
    }

    void main(){
      vec2 uv = (gl_FragCoord.xy / u_res);
      vec2 p = (uv*2.0-1.0);
      p.x *= u_res.x/u_res.y;

      // base rotation + twist by radius
      float r = length(p);
      float a = atan(p.y, p.x) + u_rot + u_twist * r*r;

      // kaleidoscope segmentation with mirroring at boundaries
      float K = max(3.0, u_k);
      float seg = 6.2831853 / K;         // segment angle
      float aa = mod(a, seg);
      // mirror across wedge centerline so adjacent wedges flip
      if(aa > seg*0.5) aa = seg - aa;

      // soft feather near edges to avoid hard lines
      float edge = min(aa, seg-aa) / (seg*0.5);
      float feather = smoothstep(0.0, u_soft + 1e-3, edge);

      // rebuild point from mirrored angle
      float a2 = aa - seg*0.5;           // center wedge
      vec2 q = vec2(cos(a2), sin(a2)) * r;

      // tunnel warp
      float tWarp = mix(1.0, 0.25 + 0.75*cos(0.2*u_time + r*8.0), u_tunnel);
      q *= tWarp;

      // zoom
      q /= u_zoom;

      vec3 col;
      if(u_mode==0 && u_hasTex){
        // map back to texture UV
        vec2 tuv = q;
        tuv.x *= u_res.y/u_res.x;  // undo aspect to keep source proportional
        tuv = tuv*0.5 + 0.5;
        // wrap
        tuv = fract(tuv);
        col = texture2D(u_tex, tuv).rgb;
      }else{
        // procedural neon
        float tt = u_time*0.25;
        float f = 0.0;
        vec2 s = q*3.0;
        for(int i=0;i<5;i++){
          s = rot2(1.3)*s + vec2(0.11,0.09);
          f += (sin(s.x*2.0)+cos(s.y*2.0))*0.25;
        }
        col = palette(f + r*2.0 + tt);
      }

      // slight glow boost
      col = pow(col, vec3(0.95));
      // feather to remove seam
      col *= feather;

      gl_FragColor = vec4(col, 1.0);
    }`;

  function compile(type, src){
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src); gl.compileShader(sh);
    if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
      throw new Error(gl.getShaderInfoLog(sh));
    }
    return sh;
  }
  const prog = gl.createProgram();
  gl.attachShader(prog, compile(gl.VERTEX_SHADER, vsrc));
  gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fsrc));
  gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog));
  gl.useProgram(prog);

  // Fullscreen triangle
  const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
  const a_pos = gl.getAttribLocation(prog, 'a_pos');
  gl.enableVertexAttribArray(a_pos);
  gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

  // Uniforms
  const u_res = gl.getUniformLocation(prog, 'u_res');
  const u_time = gl.getUniformLocation(prog, 'u_time');
  const u_tex = gl.getUniformLocation(prog, 'u_tex');
  const u_hasTex = gl.getUniformLocation(prog, 'u_hasTex');
  const u_rot = gl.getUniformLocation(prog, 'u_rot');
  const u_zoom = gl.getUniformLocation(prog, 'u_zoom');
  const u_twist = gl.getUniformLocation(prog, 'u_twist');
  const u_tunnel = gl.getUniformLocation(prog, 'u_tunnel');
  const u_soft = gl.getUniformLocation(prog, 'u_soft');
  const u_k = gl.getUniformLocation(prog, 'u_k');
  const u_mode = gl.getUniformLocation(prog, 'u_mode');
  gl.uniform1i(u_tex, 0);

  // Texture setup
  let tex = gl.createTexture(); gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
  const blank = new Uint8Array([0,0,0,255]);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,blank);

  const vid = document.getElementById('vid');
  const aud = document.getElementById('aud');

  let hasTex = false, usingVideo = false;

  // Draw helper for video/image
  function upload(element){
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,element);
    hasTex = true;
  }

  // Controls
  const wedges = document.getElementById('wedges');
  const zoom = document.getElementById('zoom');
  const spin = document.getElementById('spin');
  const twist = document.getElementById('twist');
  const tunnel = document.getElementById('tunnel');
  const soft = document.getElementById('soft');
  const modeBtn = document.getElementById('mode');
  const randomBtn = document.getElementById('random');
  const resetBtn = document.getElementById('reset');
  const mediaIn = document.getElementById('mediaIn');
  const audioIn = document.getElementById('audioIn');
  const shotBtn = document.getElementById('shot');
  const recBtn = document.getElementById('rec');
  const stopBtn = document.getElementById('stop');
  const toggle = document.getElementById('toggle');
  const dock = document.getElementById('dock');

  let params = {
    k: +wedges.value,
    zoom: +zoom.value,
    spin: +spin.value,
    twist: +twist.value,
    tunnel: +tunnel.value,
    soft: +soft.value,
    rot: 0,
    mode: 0 // 0:image, 1:proc
  };

  // Mode toggle
  modeBtn.onclick = () => {
    params.mode = (params.mode===0?1:0);
    modeBtn.textContent = 'Mode: ' + (params.mode===0 ? 'Image' : 'Fractal');
  };

  [wedges, zoom, spin, twist, tunnel, soft].forEach(el=>{
    el.addEventListener('input', ()=>{
      params.k = +wedges.value;
      params.zoom = +zoom.value;
      params.spin = +spin.value;
      params.twist = +twist.value;
      params.tunnel = +tunnel.value;
      params.soft = +soft.value;
    });
  });

  // Random / Reset
  randomBtn.onclick = ()=>{
    const rnd = (a,b)=> a + Math.random()*(b-a);
    wedges.value = Math.floor(rnd(6, 36)); zoom.value = rnd(.6, 1.8).toFixed(2);
    spin.value = rnd(-1.2, 1.2).toFixed(3);
    twist.value = rnd(-3, 3).toFixed(2);
    tunnel.value = rnd(0, 1).toFixed(3);
    soft.value = rnd(0.01, 0.12).toFixed(3);
    wedges.dispatchEvent(new Event('input'));
  };
  resetBtn.onclick = ()=>{
    wedges.value=12; zoom.value=1.1; spin.value=0.15; twist.value=0.6; tunnel.value=0.18; soft.value=0.04;
    wedges.dispatchEvent(new Event('input'));
  };

  // File inputs
  mediaIn.onchange = (e)=>{
    const f = e.target.files[0]; if(!f) return;
    const url = URL.createObjectURL(f);
    usingVideo = f.type.startsWith('video/');
    if(usingVideo){
      vid.src = url; vid.muted = true; vid.loop = true;
      vid.onloadeddata = () => { vid.play(); hasTex = true; };
    }else{
      const img = new Image(); img.onload = ()=> upload(img);
      img.src = url;
    }
  };

  // AUDIO ‚Äî WebAudio graph with wheel control
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const srcNode = audioCtx.createMediaElementSource(aud);
  const filter = audioCtx.createBiquadFilter(); filter.type='lowpass'; filter.frequency.value = 2000; filter.Q.value=0.7;
  const gain = audioCtx.createGain(); gain.gain.value = 1.0;
  const comp = audioCtx.createDynamicsCompressor();

  // For recording audio + canvas together
  const mixDest = audioCtx.createMediaStreamAudioDestination();
  srcNode.connect(filter); filter.connect(gain); gain.connect(comp);
  comp.connect(audioCtx.destination);
  comp.connect(mixDest);

  audioIn.onchange = (e)=>{
    const f = e.target.files[0]; if(!f) return;
    aud.src = URL.createObjectURL(f);
    aud.loop = true; aud.playbackRate = 1.0;
    audioCtx.resume();
    aud.play().catch(()=>{ /* autoplay might need user gesture */ });
  };

  // Wheel interaction
  const wheel = document.getElementById('wheel');
  const needle = document.getElementById('needle');
  const audioInfo = document.getElementById('audioInfo');
  let angle = 0, radiusN = 0.6; // normalized radius 0..1

  function setWheel(a, r){
    angle = a; radiusN = Math.min(1, Math.max(0, r));
    // Playback rate 0.5..2.0 from angle (wrap)
    let norm = ((a % (Math.PI*2))+Math.PI*2)%(Math.PI*2); // 0..TAU
    const rate = 0.5 + (norm/(Math.PI*2))*1.5; // 0.5..2.0
    // Filter frequency 200..12000 from radius
    const freq = 200 + radiusN * (12000-200);
    aud.playbackRate = rate;
    filter.frequency.value = freq;
    needle.style.transform = `translateX(-50%) rotate(${(norm*180/Math.PI).toFixed(1)}deg)`;
    audioInfo.textContent = `${rate.toFixed(2)}√ó ‚Ä¢ ${freq<1000?freq.toFixed(0)+'Hz':(freq/1000).toFixed(1)+'kHz'}`;
  }

  function wheelFromEvent(e){
    const rect = wheel.getBoundingClientRect();
    const cx = rect.left + rect.width/2;
    const cy = rect.top + rect.height/2;
    const x = (e.clientX ?? e.touches?.[0]?.clientX) - cx;
    const y = (e.clientY ?? e.touches?.[0]?.clientY) - cy;
    const a = Math.atan2(-x, -y);          // rotate needle like a platter
    const r = Math.min(1, Math.hypot(x,y)/(rect.width*0.5));
    return [a,r];
  }

  let wheelDown=false;
  const wdown = e=>{ wheelDown=true; const [a,r]=wheelFromEvent(e); setWheel(a,r); e.preventDefault(); };
  const wmove = e=>{ if(!wheelDown) return; const [a,r]=wheelFromEvent(e); setWheel(a,r); e.preventDefault(); };
  const wup = ()=> wheelDown=false;
  wheel.addEventListener('pointerdown', wdown); addEventListener('pointermove', wmove); addEventListener('pointerup', wup);
  wheel.addEventListener('touchstart', wdown, {passive:false}); addEventListener('touchmove', wmove, {passive:false}); addEventListener('touchend', wup);

  // Canvas gestures
  let dragging=false, lastX=0, lastY=0;
  canvas.addEventListener('pointerdown', e=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; canvas.setPointerCapture(e.pointerId); });
  canvas.addEventListener('pointerup', e=>{ dragging=false; });
  canvas.addEventListener('pointermove', e=>{
    if(!dragging) return;
    const dx = e.clientX - lastX, dy = e.clientY - lastY;
    params.rot += dx * 0.005;        // rotate by horizontal drag
    params.twist += dy * 0.002;      // adjust swirl by vertical drag
    lastX = e.clientX; lastY = e.clientY;
  });

  // Pinch/rotate gesture for mobile (two fingers)
  let touchCache = [];
  const dist = (a,b)=>Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);
  const ang = (a,b)=>Math.atan2(b.clientY-a.clientY, b.clientX-a.clientX);
  canvas.addEventListener('touchstart', e=>{ touchCache = [...e.touches]; }, {passive:false});
  canvas.addEventListener('touchmove', e=>{
    if(e.touches.length===2 && touchCache.length===2){
      const a0=touchCache[0], b0=touchCache[1];
      const a1=e.touches[0], b1=e.touches[1];
      const d0=dist(a0,b0), d1=dist(a1,b1);
      const scale=(d1/d0);
      params.zoom /= Math.max(0.5, Math.min(2, scale));  // pinch zoom
      const r0=ang(a0,b0), r1=ang(a1,b1);
      params.twist += (r1-r0)*1.5;                       // two-finger rotate -> twist
      touchCache=[...e.touches];
      e.preventDefault();
    }
  }, {passive:false});
  canvas.addEventListener('touchend', e=>{ touchCache=[...e.touches]; }, {passive:true});

  // Toggle Dock
  toggle.onclick = ()=> dock.classList.toggle('collapsed');
  addEventListener('keydown', e=>{ if(e.key==='h' || e.key==='H') dock.classList.toggle('collapsed'); });

  // Screenshot
  shotBtn.onclick = ()=>{
    const a = document.createElement('a');
    a.download = 'kaleidoscope.png';
    a.href = canvas.toDataURL('image/png');
    a.click();
  };

  // Recording
  let recorder=null, chunks=[];
  recBtn.onclick = ()=>{
    try{
      const fps = 60;
      const streamV = canvas.captureStream(fps);
      // try to include audio
      let stream = streamV;
      if (mixDest && mixDest.stream && mixDest.stream.getAudioTracks().length){
        const combined = new MediaStream([...streamV.getVideoTracks(), ...mixDest.stream.getAudioTracks()]);
        stream = combined;
      }
      recorder = new MediaRecorder(stream, {mimeType: 'video/webm;codecs=vp9,opus'});
      chunks = [];
      recorder.ondataavailable = e=>{ if(e.data.size>0) chunks.push(e.data); };
      recorder.onstop = ()=>{
        const blob = new Blob(chunks, {type:'video/webm'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'kaleidoscope.webm';
        a.click();
      };
      recorder.start();
      recBtn.disabled = true; stopBtn.disabled = false;
    }catch(err){
      alert('Recording not supported in this browser: ' + err);
    }
  };
  stopBtn.onclick = ()=>{ if(recorder){ recorder.stop(); recBtn.disabled=false; stopBtn.disabled=true; } };

  // Animate
  let t0 = performance.now()/1000;
  function frame(){
    fit();
    const t = performance.now()/1000; const dt = t - t0; t0 = t;
    params.rot += params.spin * dt;

    gl.useProgram(prog);
    gl.uniform2f(u_res, canvas.width, canvas.height);
    gl.uniform1f(u_time, t);
    gl.uniform1f(u_rot, params.rot);
    gl.uniform1f(u_zoom, params.zoom);
    gl.uniform1f(u_twist, params.twist);
    gl.uniform1f(u_tunnel, params.tunnel);
    gl.uniform1f(u_soft, params.soft);
    gl.uniform1f(u_k, params.k);
    gl.uniform1i(u_mode, params.mode);
    gl.uniform1i(u_hasTex, hasTex?1:0);

    if(usingVideo && vid.readyState >= 2){
      upload(vid); // update video frame to texture
    }

    gl.drawArrays(gl.TRIANGLES, 0, 3);
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // Nice defaults
  setWheel(Math.PI*1.2, 0.5);

  // Small iOS/Autoplay helper
  addEventListener('pointerdown', ()=>{
    if(audioCtx.state !== 'running') audioCtx.resume();
  }, {once:true});

})();
</script>
</body>
</html>
