

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Kaleidoscope — Touch Turntable (Fixed)</title>
<style>
  :root{ --glass: rgba(12,12,16,.82); --fg:#eaf0ff; --muted:#a9b2c9; --line:#2a3040; --accent:#7ae7ff; }
  html,body{ margin:0; height:100%; background:#000; color:var(--fg); font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial; }
  canvas{ display:block; width:100vw; height:100vh; touch-action:none; cursor:grab; }

  /* Dock: real box, scrollable, hideable */
  #dock{
    position:fixed; right:12px; top:12px; z-index:40;
    background:var(--glass); color:var(--fg);
    padding:14px 14px 10px; border-radius:16px; backdrop-filter: blur(12px);
    max-height:62vh; width:300px; overflow:auto; box-shadow:0 14px 50px rgba(0,0,0,.5);
    border:1px solid rgba(122,231,255,.12);
  }
  #dock h3{ margin:0 0 8px; font-weight:600; font-size:16px; letter-spacing:.4px; }
  #dock .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  #dock label{ font-size:12px; color:var(--muted); }
  #hideDock{ position:absolute; right:8px; top:8px; background:transparent; border:0; color:var(--muted); font-size:16px; cursor:pointer; }
  #showDock{ position:fixed; right:12px; top:12px; z-index:30; display:none; }

  .knob{ width:84px; height:84px; border-radius:50%; border:2px solid var(--line); display:inline-flex; align-items:center; justify-content:center; margin:6px; user-select:none; position:relative; }
  .knob span{ position:absolute; bottom:-18px; font-size:12px; color:var(--muted); }

  .btn{ appearance:none; border:1px solid var(--line); background:#0a0f18; color:#eaf0ff; padding:8px 10px; border-radius:12px; cursor:pointer; }
  .btn:active{ transform:translateY(1px); }
  .wide{ width:100%; }

  input[type="range"]{ width:100%; }

  #file{ position:fixed; left:12px; top:12px; z-index:35; }
  #recBtn{ position:fixed; left:12px; top:56px; z-index:35; }

  @media (max-width:640px){
    #dock{ width:88vw; right:6vw; }
  }
</style>
</head>
<body>
  <!-- Controls -->
  <input id="file" type="file" accept="image/*,video/*,audio/*" class="btn" />
  <button id="recBtn" class="btn">● REC</button>

  <div id="dock">
    <button id="hideDock">✕</button>
    <h3>Kaleidoscope Controls</h3>

    <div class="row">
      <div class="knob" data-param="speed"><span>Speed</span></div>
      <div class="knob" data-param="twist"><span>Twist</span></div>
      <div class="knob" data-param="zoom"><span>Zoom</span></div>
    </div>

    <label>Wedges</label>
    <input id="wedges" type="range" min="4" max="48" step="1" value="12" />

    <label>Soft Edge</label>
    <input id="soft" type="range" min="0" max="1" step="0.01" value="0.35" />

    <div class="row" style="margin-top:8px;">
      <button id="resetBtn" class="btn">Reset</button>
      <button id="saveBtn" class="btn">Screenshot</button>
      <button id="hideBtn" class="btn">Hide Panel (D)</button>
    </div>

    <div style="margin-top:10px; font-size:12px; color:var(--muted)">Drag on canvas like a turntable: tweaks spin + twist and also audio playback rate.</div>
  </div>
  <button id="showDock" class="btn">Show Controls</button>

  <!-- Stage -->
  <canvas id="c"></canvas>

<script>
(function(){
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  let W=0, H=0, DPR=1, cx=0, cy=0, R=0;

  // Rendering state
  const state = {
    k: 12,               // wedge count
    angle: 0,            // global rotation
    speed: 0.6,          // spin speed
    twist: 0.0,          // per-wedge twist
    zoom: 1.0,           // scale
    soft: 0.35,          // soft-edge vignette
  };

  // Source media
  let useVideo = false, useImage = true, useAudioOnly = false;
  const img = new Image();
  const vid = document.createElement('video');
  vid.muted = true; vid.loop = true; vid.playsInline = true; vid.crossOrigin = 'anonymous';

  // Audio setup (simple playback rate control)
  const audio = new Audio();
  audio.crossOrigin = 'anonymous';
  audio.loop = true; audio.volume = 1.0;
  let audioLoaded = false;

  function fit(){
    DPR = window.devicePixelRatio || 1;
    canvas.width = Math.floor(innerWidth * DPR);
    canvas.height = Math.floor(innerHeight * DPR);
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    ctx.imageSmoothingQuality = 'high';
    ctx.imageSmoothingEnabled = true;
    W = innerWidth; H = innerHeight; cx = W/2; cy = H/2; R = Math.hypot(W,H);
  }
  window.addEventListener('resize', fit); fit();

  // Wedge path (with tiny epsilon to remove seam lines)
  function wedgePath(halfA){
    const eps = 0.002; // radians
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(R, -(halfA+eps));
    ctx.lineTo(R,  (halfA+eps));
    ctx.closePath();
  }

  // Draw current frame
  function draw(){
    ctx.clearRect(0,0,W,H);

    // Fill background black to avoid video alpha artifacts
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,W,H);

    const step = Math.PI*2 / state.k;
    const halfA = step/2;

    ctx.save();
    ctx.translate(cx, cy);

    for(let i=0;i<state.k;i++){
      ctx.save();
      // rotate to wedge
      ctx.rotate(i*step + state.angle);
      // clip to wedge sector
      wedgePath(halfA);
      ctx.clip();

      // mirror every other wedge horizontally
      if (i % 2 === 1) ctx.scale(-1, 1);

      // apply twist & zoom
      ctx.rotate(state.twist);
      ctx.scale(state.zoom, state.zoom);

      // draw media centered
      if (useVideo && vid.readyState >= 2) {
        drawMedia(vid);
      } else if (useImage && img.complete && img.naturalWidth) {
        drawMedia(img);
      } else if (useAudioOnly) {
        // pretty fallback: rotating radial gradient bars
        drawAudioViz();
      }

      ctx.restore();
    }

    // soft edge vignette (fade near edges)
    if (state.soft > 0) {
      const g = ctx.createRadialGradient(0,0,0, 0,0, R);
      g.addColorStop(0.0, 'rgba(0,0,0,0)');
      g.addColorStop(Math.max(0.0001,1.0 - state.soft), 'rgba(0,0,0,0)');
      g.addColorStop(1.0, 'rgba(0,0,0,0.9)');
      ctx.fillStyle = g;
      ctx.fillRect(-cx, -cy, W, H);
    }

    ctx.restore();
  }

  function drawMedia(media){
    // cover strategy: scale so the shorter side fits the wedge radius
    const iw = media.videoWidth || media.naturalWidth;
    const ih = media.videoHeight || media.naturalHeight;
    if (!iw || !ih) return;

    const s = Math.max(R*2/iw, R*2/ih) * 1.02; // small overdraw to prevent seams
    const dw = iw*s, dh = ih*s;
    ctx.drawImage(media, -dw/2, -dh/2, dw, dh);
  }

  function drawAudioViz(){
    const bars = 120;
    for(let i=0;i<bars;i++){
      const t = (i/bars);
      const r = R*0.25 + Math.sin(perfNow*0.002 + i*0.12)*R*0.08;
      ctx.save();
      ctx.rotate(i*(Math.PI*2/bars));
      ctx.fillStyle = `hsl(${(i*3+perfNow*0.05)%360} 90% 60%)`;
      ctx.fillRect(r, -4, R*0.18, 8);
      ctx.restore();
    }
  }

  // Animation loop
  let perfNow = 0, lastT = 0;
  function loop(t){
    perfNow = t;
    const dt = Math.min(32, t - lastT); lastT = t;
    state.angle += state.speed * dt * 0.001; // rad/s approx
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Pointer turntable behavior
  let lastAngle = null;
  canvas.addEventListener('pointerdown', e=>{ canvas.setPointerCapture(e.pointerId); });
  canvas.addEventListener('pointerup', ()=>{ lastAngle=null; });
  canvas.addEventListener('pointerleave', ()=>{ lastAngle=null; });
  canvas.addEventListener('pointermove', (e)=>{
    if (!e.buttons) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - (rect.left + rect.width/2);
    const y = e.clientY - (rect.top  + rect.height/2);
    const ang = Math.atan2(y, x);
    if (lastAngle !== null){
      let dA = ang - lastAngle;
      // unwrap
      if (dA > Math.PI) dA -= Math.PI*2;
      if (dA < -Math.PI) dA += Math.PI*2;
      state.speed += dA * 1.2;         // spin feel
      state.twist += dA * 0.35;        // subtle twist
      // audio: adjust playback rate gently
      if (audioLoaded){
        const r = 1 + state.speed*0.05;
        audio.playbackRate = Math.min(2.0, Math.max(0.5, r));
      }
    }
    lastAngle = ang;
  });

  // Upload handler (image / video / audio)
  const file = document.getElementById('file');
  file.onchange = async (e)=>{
    const f = e.target.files[0]; if (!f) return;
    const url = URL.createObjectURL(f);
    if (f.type.startsWith('video/')){
      vid.src = url; await vid.play();
      useVideo = true; useImage = false; useAudioOnly = false;
    } else if (f.type.startsWith('image/')){
      img.onload = ()=>{ useVideo=false; useImage=true; useAudioOnly=false; };
      img.src = url;
    } else if (f.type.startsWith('audio/')){
      audio.src = url; await audio.play(); audioLoaded = true;
      useVideo = false; useImage = false; useAudioOnly = true;
    }
  };

  // Knobs (no library)
  document.querySelectorAll('.knob').forEach(k=>{
    let startA=0, startVal=0, active=false;
    const param = k.dataset.param;
    function valClamp(p, v){
      if (p==='speed') return Math.max(-5, Math.min(5, v));
      if (p==='twist') return Math.max(-Math.PI, Math.min(Math.PI, v));
      if (p==='zoom')  return Math.max(0.2, Math.min(6, v));
      return v;
    }
    const move = (clientX, clientY)=>{
      if(!active) return;
      const r = k.getBoundingClientRect();
      const x = clientX - (r.left + r.width/2);
      const y = clientY - (r.top + r.height/2);
      const a = Math.atan2(y, x);
      const d = a - startA;
      state[param] = valClamp(param, startVal + d);
    };
    const up = ()=>{ active=false; window.removeEventListener('pointermove', onPM); window.removeEventListener('pointerup', up); };
    const onPM = (e)=> move(e.clientX, e.clientY);
    k.addEventListener('pointerdown', (e)=>{
      active = true;
      const r = k.getBoundingClientRect();
      const x = e.clientX - (r.left + r.width/2);
      const y = e.clientY - (r.top + r.height/2);
      startA = Math.atan2(y, x);
      startVal = state[param];
      window.addEventListener('pointermove', onPM);
      window.addEventListener('pointerup', up);
    });
  });

  // Range controls
  const wedges = document.getElementById('wedges');
  wedges.addEventListener('input', ()=>{ state.k = Math.max(3, (+wedges.value|0)); });
  const soft = document.getElementById('soft');
  soft.addEventListener('input', ()=>{ state.soft = +soft.value; });

  // Reset / Screenshot
  document.getElementById('resetBtn').onclick = ()=>{
    state.speed = 0.6; state.twist = 0.0; state.zoom = 1.0; state.angle = 0; state.k = +wedges.value; state.soft = +soft.value;
    if (audioLoaded) audio.playbackRate = 1.0;
  };
  document.getElementById('saveBtn').onclick = ()=>{
    const a = document.createElement('a');
    canvas.toBlob((blob)=>{
      a.href = URL.createObjectURL(blob);
      a.download = 'kaleidoscope.png'; a.click();
    });
  };

  // Hide / Show dock
  const dock = document.getElementById('dock');
  document.getElementById('hideDock').onclick = ()=>{ dock.style.display='none'; document.getElementById('showDock').style.display='block'; };
  document.getElementById('hideBtn').onclick = ()=>{ dock.style.display='none'; document.getElementById('showDock').style.display='block'; };
  document.getElementById('showDock').onclick = ()=>{ dock.style.display='block'; document.getElementById('showDock').style.display='none'; };
  document.addEventListener('keydown', (e)=>{ if(e.key==='d'||e.key==='D'){ const s = getComputedStyle(dock).display; if(s!=='none'){ dock.style.display='none'; document.getElementById('showDock').style.display='block'; } else { dock.style.display='block'; document.getElementById('showDock').style.display='none'; } } });

  // Recording (canvas only)
  const recBtn = document.getElementById('recBtn');
  let mediaRecorder=null, chunks=[];
  recBtn.onclick = ()=>{
    if (!mediaRecorder || mediaRecorder.state==='inactive'){
      const stream = canvas.captureStream(30);
      mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
      mediaRecorder.ondataavailable = e=>{ if (e.data && e.data.size) chunks.push(e.data); };
      mediaRecorder.onstop = ()=>{
        const blob = new Blob(chunks, { type:'video/webm' });
        chunks = [];
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'kaleidoscope.webm'; a.click();
      };
      mediaRecorder.start(); recBtn.textContent='■ STOP';
    } else {
      mediaRecorder.stop(); recBtn.textContent='● REC';
    }
  };
})();
</script>
</body>
</html>
