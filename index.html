<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Kaleidoscope â€¢ Perfect Interactive (Image Upload)</title>
<style>
  :root{ --glass: rgba(12,12,16,.85); --fg:#f6f7fb; --muted:#bac1d6; --line:#2a3040; }
  html,body{ margin:0; height:100%; background:#000; color:var(--fg); font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial }
  canvas{ display:block; width:100vw; height:100vh; touch-action:none; cursor:grab }
  #hide{ position:fixed; right:10px; top:10px; z-index:30; background:var(--glass); border:1px solid var(--line); color:var(--fg); padding:8px 10px; border-radius:12px; backdrop-filter:blur(12px); cursor:pointer }
  #dock{
    position:fixed; left:50%; top:10px; transform:translateX(-50%);
    display:flex; gap:10px; align-items:center; z-index:25;
    background:var(--glass); border:1px solid var(--line); border-radius:16px; padding:10px 12px; backdrop-filter:blur(12px);
    box-shadow:0 10px 30px rgba(0,0,0,.35)
  }
  #dock .group{ display:flex; gap:10px; align-items:center }
  #dock label{ font-size:12px; color:var(--muted) }
  #dock input[type=range]{ width:120px }
  #dock button, .chip{ background:#0f1320; border:1px solid var(--line); color:var(--fg); border-radius:12px; padding:8px 10px; font-size:13px; cursor:pointer }
  #wheel{ width:60px; height:60px; border-radius:50%; position:relative; user-select:none; background:radial-gradient(120% 120% at 30% 30%, #15192a, #0b0f1e); border:1px solid var(--line); box-shadow:inset 0 0 0 2px #0b0f1e, 0 8px 16px rgba(0,0,0,.35) }
  #wheel:before{ content:""; position:absolute; left:50%; top:50%; width:6px; height:6px; border-radius:50%; background:#9cf; border:1px solid #67c; transform:translate(-50%,-50%) }
  #wheel .tick{ position:absolute; left:50%; top:4px; width:2px; height:12px; background:#8ae; transform-origin:50% 26px; border-radius:1px; opacity:.85 }
  #wheel .handle{ position:absolute; left:50%; top:-4px; width:8px; height:18px; background:#9cf; border-radius:2px; transform:translateX(-50%); box-shadow:0 0 10px rgba(122,231,255,.6) }
  @media (max-width:760px){ #dock{ flex-wrap:wrap; gap:8px } #dock input[type=range]{ width:90px } }
  #toast{ position:fixed; left:50%; bottom:14px; transform:translateX(-50%); background:var(--glass); border:1px solid var(--line); padding:8px 12px; border-radius:12px; font-size:13px; color:var(--muted); z-index:40; opacity:0; pointer-events:none; transition:.3s opacity }
  #toast.show{ opacity:1 }
</style>
</head>
<body>
<canvas id="gl"></canvas>
<button id="hide" aria-label="Hide or show controls">Hide UI</button>
<div id="dock" role="toolbar" aria-label="Kaleidoscope controls">
  <div class="group">
    <input id="file" type="file" accept="image/*,image/heic,image/heif" title="Upload image" style="display:none"/>
    <button id="uploadBtn">Upload</button>
    <button id="clear">Clear</button>
    <button id="shot">Screenshot</button>
  </div>
  <div class="group">
    <div id="wheel" title="Turntable speed">
      <div class="tick" style="transform:translateX(-50%) rotate(0deg)"></div>
      <div class="tick" style="transform:translateX(-50%) rotate(30deg)"></div>
      <div class="tick" style="transform:translateX(-50%) rotate(60deg)"></div>
      <div class="tick" style="transform:translateX(-50%) rotate(90deg)"></div>
      <div class="tick" style="transform:translateX(-50%) rotate(120deg)"></div>
      <div class="tick" style="transform:translateX(-50%) rotate(150deg)"></div>
      <div class="handle"></div>
    </div>
    <span class="chip"><span id="rpm">0.00</span> rpm</span>
  </div>
  <div class="group">
    <label>Wedges</label><input id="wedges" type="range" min="4" max="36" step="1" value="12">
    <label>Zoom</label><input id="zoom" type="range" min="0.3" max="3.0" step="0.01" value="1.2">
    <label>Twist</label><input id="twist" type="range" min="-2.0" max="2.0" step="0.01" value="0.25">
    <label style="display:flex;align-items:center;gap:6px"><input id="pulseToggle" type="checkbox"> Pulse</label>
    <button id="reset">Reset</button>
  </div>
</div>
  <div class="group">
    <div id="wheel" title="Turntable speed">
      <div class="tick" style="transform:translateX(-50%) rotate(0deg)"></div>
      <div class="tick" style="transform:translateX(-50%) rotate(30deg)"></div>
      <div class="tick" style="transform:translateX(-50%) rotate(60deg)"></div>
      <div class="tick" style="transform:translateX(-50%) rotate(90deg)"></div>
      <div class="tick" style="transform:translateX(-50%) rotate(120deg)"></div>
      <div class="tick" style="transform:translateX(-50%) rotate(150deg)"></div>
      <div class="handle"></div>
    </div>
    <span class="chip"><span id="rpm">0.00</span> rpm</span>
  </div>
  <div class="group">
    <label>Wedges</label><input id="wedges" type="range" min="4" max="36" step="1" value="12">
    <label>Zoom</label><input id="zoom" type="range" min="0.3" max="3.0" step="0.01" value="1.2">
    <label>Twist</label><input id="twist" type="range" min="-2.0" max="2.0" step="0.01" value="0.25">
    <button id="reset">Reset</button>
  </div>
</div>
<div id="emptyOverlay" style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none;z-index:60">
  <button id="bigUpload" style="pointer-events:auto;background:rgba(12,12,16,.92);border:1px solid #2a3040;color:#f6f7fb;padding:16px 20px;border-radius:14px;font-size:17px">ðŸ“· Load Image</button>ðŸ“· Load Image</button>
</div>
<div id="toast">Tip: drag on canvas to rotate (â†”) and twist (â†•). Pinch to zoom. Doubleâ€‘tap for pulse âš¡</div>
<script>
(() => {
  // ---------- Setup ----------
  const canvas = document.getElementById('gl');
  const gl = canvas.getContext('webgl', { antialias:false, preserveDrawingBuffer:true });
  if(!gl){ alert('WebGL not supported'); return; }

  function fit(){
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const w = Math.floor(innerWidth * dpr);
    const h = Math.floor(innerHeight * dpr);
    if(canvas.width!==w || canvas.height!==h){ canvas.width = w; canvas.height = h; }
    gl.viewport(0,0,gl.drawingBufferWidth,gl.drawingBufferHeight);
  }
  addEventListener('resize', fit, {passive:true}); fit();

  // ---------- Shaders ----------
  const vsrc = `
    attribute vec2 a_pos; varying vec2 v_uv; void main(){ v_uv=a_pos*0.5+0.5; gl_Position=vec4(a_pos,0.0,1.0);} 
  `;

  const fsrc = `
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif
    varying vec2 v_uv; uniform vec2 u_res; uniform float u_time; uniform sampler2D u_tex; uniform bool u_hasTex; uniform float u_rot; uniform float u_zoom; uniform float u_twist; uniform float u_k; uniform float u_pulse; uniform bool u_enablePulse; uniform vec2 u_touch;

    float hash21(vec2 p){ p=fract(p*vec2(123.34,456.21)); p+=dot(p,p+45.32); return fract(p.x*p.y);} 
    float noise(vec2 p){ vec2 i=floor(p), f=fract(p); float a=hash21(i), b=hash21(i+vec2(1.,0.)); float c=hash21(i+vec2(0.,1.)), d=hash21(i+1.); vec2 u=f*f*(3.-2.*f); return mix(a,b,u.x)+ (c-a)*u.y*(1.-u.x) + (d-b)*u.x*u.y; }
    vec3 fallbackTex(vec2 uv){ vec2 p=(uv-0.5)*2.0; float t=u_time*0.2; float n=0.0; for(int i=0;i<4;i++){ float s=float(i+1); n+=noise(p*s+t*s);} n/=4.0; float a=0.5+0.5*sin(6.283*(n+t)); vec3 col=0.5+0.5*cos(6.283*vec3(0.,0.33,0.66)+a*3.2); return pow(col, vec3(1.2)); }

    vec3 sampleTex(vec2 uv){ return u_hasTex ? texture2D(u_tex, uv).rgb : fallbackTex(uv); }

    void main(){
      vec2 uv = v_uv; 
      vec2 p = (uv-0.5); p.x *= u_res.x/u_res.y;
      float k = max(2.0, floor(u_k));
      float ang = atan(p.y,p.x) + u_rot; 
      float rad = length(p);
      float seg = 6.28318530718 / k;
      // fold into wedge and mirror across edges (seamless mirror)
      float a = mod(ang + 1e-5, seg); // tiny bias avoids sampling both sides
      a = min(a, seg - a);            // mirror fold
      // radial twist
      a += u_twist * rad * 2.0;
      // rebuild cartesian after fold
      vec2 q = vec2(cos(a), sin(a)) * rad;
      // zoom
      q /= u_zoom;
      // map back to 0..1 for sampling
      vec2 suv = q; suv.x /= (u_res.x/u_res.y); suv = suv*0.5 + 0.5;

      // pulse glow (double tap) â€” only when pulse > 0 to avoid stray ring
      float d = distance(uv, u_touch);
      float ring = 0.0;
      if(u_enablePulse && u_pulse > 0.001){
        ring = smoothstep(0.0, 0.02 + 0.15*u_pulse, abs(d - (0.15+0.6*u_pulse)));
      }
      float glow = ring * (0.6 + 0.6*u_pulse);

      vec3 col = sampleTex(suv);
      float vig = smoothstep(1.1, 0.25, length(p));
      col *= vig + 0.25;
      col += glow*vec3(1.2,1.0,1.6);
      // soften seam just a touch
      col *= 0.985 + 0.015*cos(a*k*0.5);
      gl_FragColor = vec4(col, 1.0);
    }
  `;

  function toast(msg){ const t=document.getElementById('toast'); t.textContent=msg; t.classList.add('show'); clearTimeout(toast._to); t._to=setTimeout(()=>t.classList.remove('show'), 2200); }
  function compile(type, src){ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){ const log=gl.getShaderInfoLog(s); toast((type===gl.VERTEX_SHADER?'Vertex':'Fragment')+': '+log); throw log; } return s; }
  function program(vs, fs){ const p=gl.createProgram(); gl.attachShader(p,compile(gl.VERTEX_SHADER,vs)); gl.attachShader(p,compile(gl.FRAGMENT_SHADER,fs)); gl.linkProgram(p); if(!gl.getProgramParameter(p, gl.LINK_STATUS)){ const log=gl.getProgramInfoLog(p); toast('Link: '+log); throw log; } return p; }

  const prog = program(vsrc, fsrc); gl.useProgram(prog);
  const quad = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, quad); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ -1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1 ]), gl.STATIC_DRAW);
  const a_pos = gl.getAttribLocation(prog, 'a_pos'); gl.enableVertexAttribArray(a_pos); gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

  const U = n => gl.getUniformLocation(prog, n);
  const u_res=U('u_res'), u_time=U('u_time'), u_tex=U('u_tex'), u_hasTex=U('u_hasTex'), u_rotU=U('u_rot'), u_zoomU=U('u_zoom'), u_twistU=U('u_twist'), u_k=U('u_k'), u_pulse=U('u_pulse'), u_enablePulse=U('u_enablePulse'), u_touch=U('u_touch');

  // Texture (NPOT-safe)
  const mediaTex = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, mediaTex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.uniform1i(u_tex, 0);

  let hasTex=false;
  function uploadToTex(img){
    try{
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, mediaTex);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img);
      hasTex=true;
      emptyOverlay.style.display='none';
    }catch(err){
      toast('Upload failed: '+err);
    }
  }

  // ---------- Controls ----------
  const file=document.getElementById('file'), uploadBtn=document.getElementById('uploadBtn'), clearBtn=document.getElementById('clear'), shotBtn=document.getElementById('shot'), hideBtn=document.getElementById('hide');
  const pulseToggle=document.getElementById('pulseToggle');
  const emptyOverlay=document.getElementById('emptyOverlay'), bigUpload=document.getElementById('bigUpload');
  const zoom=document.getElementById('zoom'), twist=document.getElementById('twist'), wedges=document.getElementById('wedges'), resetBtn=document.getElementById('reset');

  let rot=0, rpm=0, zoomVal=parseFloat(zoom.value), twistVal=parseFloat(twist.value), wedgesVal=parseFloat(wedges.value);

  // Turntable wheel â†’ rpm
  const wheel=document.getElementById('wheel'), rpmEl=document.getElementById('rpm');
  let wheelDragging=false, wheelAngle=0, lastAngle=0, lastTime=performance.now();
  function wheelAngleFromEvent(e){ const r=wheel.getBoundingClientRect(); const cx=r.left+r.width/2, cy=r.top+r.height/2; const x=(e.touches?e.touches[0].clientX:e.clientX)-cx; const y=(e.touches?e.touches[0].clientY:e.clientY)-cy; return Math.atan2(y,x); }
  function startWheel(e){ wheelDragging=true; lastAngle=wheelAngleFromEvent(e); lastTime=performance.now(); e.preventDefault(); }
  function moveWheel(e){ if(!wheelDragging) return; const a=wheelAngleFromEvent(e); let da=a-lastAngle; if(da> Math.PI) da-=2*Math.PI; if(da<-Math.PI) da+=2*Math.PI; wheelAngle+=da; const t=performance.now(); const dt=(t-lastTime)/1000; const rps=(da/(2*Math.PI))/Math.max(dt,1e-4); rpm = rpm*0.85 + (rps*60)*0.15; lastAngle=a; lastTime=t; wheel.style.transform=`rotate(${wheelAngle}rad)`; rpmEl.textContent=rpm.toFixed(2); e.preventDefault(); }
  function endWheel(){ wheelDragging=false; }
  wheel.addEventListener('mousedown', startWheel); wheel.addEventListener('touchstart', startWheel, {passive:false});
  addEventListener('mousemove', moveWheel, {passive:false}); addEventListener('touchmove', moveWheel, {passive:false});
  addEventListener('mouseup', endWheel); addEventListener('touchend', endWheel);

  // Sliders
  zoom.addEventListener('input', ()=> zoomVal=parseFloat(zoom.value));
  twist.addEventListener('input',()=> twistVal=parseFloat(twist.value));
  wedges.addEventListener('input',()=> wedgesVal=parseFloat(wedges.value));
  resetBtn.addEventListener('click', ()=>{ rpm=0; rot=0; zoomVal=1.2; twistVal=0.25; wedgesVal=12; zoom.value=zoomVal; twist.value=twistVal; wedges.value=wedgesVal; rpmEl.textContent=rpm.toFixed(2); wheelAngle=0; wheel.style.transform='rotate(0rad)'; toast('Reset'); });

  // Hide UI
  const dock=document.getElementById('dock'); let dockVisible=true;
  hideBtn.addEventListener('click', ()=>{ dockVisible=!dockVisible; dock.style.display=dockVisible?'flex':'none'; hideBtn.textContent=dockVisible?'Hide UI':'Show UI'; });

  // File
  file.addEventListener('change', (e)=>{
    const f=e.target.files && e.target.files[0]; if(!f) return;
    if(!f.type || (!f.type.startsWith('image/') && !/heic|heif/i.test(f.name))){ toast('Please choose an image'); return; }
    const img = new Image();
    img.onload=()=>{ uploadToTex(img); toast('Image loaded'); };
    img.onerror=()=>toast('Could not load that image');
    img.src = URL.createObjectURL(f);
  });
  // Big central upload button
  bigUpload.addEventListener('click', ()=> file.click());
  uploadBtn.addEventListener('click', ()=> file.click());
  // Drag & drop onto canvas
  ;['dragenter','dragover'].forEach(ev=> canvas.addEventListener(ev, e=>{ e.preventDefault(); e.dataTransfer.dropEffect='copy'; }));
  canvas.addEventListener('drop', e=>{
    e.preventDefault(); const f=e.dataTransfer.files && e.dataTransfer.files[0]; if(!f) return;
    if(!f.type || (!f.type.startsWith('image/') && !/heic|heif/i.test(f.name))){ toast('Drop an image file'); return; }
    const img=new Image(); img.onload=()=>{ uploadToTex(img); toast('Image loaded'); }; img.onerror=()=>toast('Could not load that image'); img.src=URL.createObjectURL(f);
  });
  // Pulse toggle
  pulseToggle.addEventListener('change', ()=>{ toast(pulseToggle.checked?'Pulse ON':'Pulse OFF'); }); const f=e.dataTransfer.files && e.dataTransfer.files[0]; if(!f) return;
    if(!f.type || (!f.type.startsWith('image/') && !/heic|heif/i.test(f.name))){ toast('Drop an image file'); return; }
    const img=new Image(); img.onload=()=>{ uploadToTex(img); toast('Image loaded'); }; img.onerror=()=>toast('Could not load that image'); img.src=URL.createObjectURL(f);
  }); return; }
    const img = new Image(); img.onload=()=>{ uploadToTex(img); toast('Image loaded'); }; img.src=URL.createObjectURL(f);
  });
  clearBtn.addEventListener('click', ()=>{ hasTex=false; emptyOverlay.style.display='flex'; toast('Cleared â€” neon plasma fallback'); }); });

  // Screenshot
  shotBtn.addEventListener('click', ()=>{
    const a=document.createElement('a'); a.download='kaleidoscope.png'; a.href=canvas.toDataURL('image/png'); a.click();
  });

  // ---------- Gestures on canvas ----------
  let dragging=false, lastX=0, lastY=0; 
  let pulse=0.0, lastTap=0; 
  let touchUV=[0.5,0.5];

  // Multi-touch pinch
  const pointers=new Map();
  function pointerDown(e){ if(e.target!==canvas) return; canvas.setPointerCapture(e.pointerId); pointers.set(e.pointerId,{x:e.clientX,y:e.clientY}); if(pointers.size===1){ dragging=true; lastX=e.clientX; lastY=e.clientY; }
    // double tap
    const now=performance.now(); if(now-lastTap<320){ pulse=1.0; toast('Pulse!'); } lastTap=now;
    updateTouchUV(e);
  }
  function pointerMove(e){ if(!pointers.has(e.pointerId)) return; pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
    if(pointers.size===1 && dragging){ const dx=e.clientX-lastX, dy=e.clientY-lastY; rot += dx * 0.01; twistVal = Math.max(-2, Math.min(2, twistVal + dy * 0.003)); twist.value = twistVal.toFixed(2); lastX=e.clientX; lastY=e.clientY; }
    if(pointers.size===2){ const pts=[...pointers.values()]; const dx=pts[1].x-pts[0].x, dy=pts[1].y-pts[0].y; const dist=Math.hypot(dx,dy); if(!pointerMove._lastD){ pointerMove._lastD=dist; pointerMove._lastA=Math.atan2(dy,dx);} else { const ratio=dist/ Math.max(1, pointerMove._lastD); zoomVal = Math.min(3, Math.max(0.3, zoomVal / ratio)); zoom.value=zoomVal; const a=Math.atan2(dy,dx); rot += (a - pointerMove._lastA); pointerMove._lastD=dist; pointerMove._lastA=a; }
    }
    updateTouchUV(e);
  }
  function pointerUp(e){ pointers.delete(e.pointerId); if(pointers.size<2){ pointerMove._lastD=null; pointerMove._lastA=null; } if(pointers.size===0){ dragging=false; } }
  function updateTouchUV(e){ const r=canvas.getBoundingClientRect(); touchUV=[ (e.clientX-r.left)/r.width, (e.clientY-r.top)/r.height ]; }

  canvas.addEventListener('pointerdown', pointerDown); 
  canvas.addEventListener('pointermove', pointerMove);
  canvas.addEventListener('pointerup', pointerUp); 
  canvas.addEventListener('pointercancel', pointerUp);

  // ---------- Render ----------
  let t0=performance.now();
  function frame(){
    const t=performance.now(); const dt=(t-t0)/1000; t0=t;
    rot += (rpm * 2*Math.PI / 60) * dt; // wheel spin
    pulse *= 0.935;

    gl.useProgram(prog);
    gl.uniform2f(u_res, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.uniform1f(u_time, t/1000);
    gl.uniform1f(u_rotU, rot);
    gl.uniform1f(u_zoomU, zoomVal);
    gl.uniform1f(u_twistU, twistVal);
    gl.uniform1f(u_k, wedgesVal);
    gl.uniform1f(u_pulse, pulse);
    gl.uniform1i(u_enablePulse, pulseToggle && pulseToggle.checked ? 1 : 0);
    gl.uniform2f(u_touch, touchUV[0], touchUV[1]);
    gl.uniform1i(u_hasTex, hasTex?1:0);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
    requestAnimationFrame(frame);
  }
  frame();

  // First-run tip
  setTimeout(()=>document.getElementById('toast').classList.add('show'), 400);
  setTimeout(()=>document.getElementById('toast').classList.remove('show'), 2600);
})();
</script>
</body>
</html>
